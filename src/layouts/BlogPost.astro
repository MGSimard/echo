---
import type { CollectionEntry } from "astro:content";
import BaseHead from "@/components/BaseHead.astro";
import Footer from "@/components/Footer.astro";
import FormattedDate from "@/components/FormattedDate.astro";
import Header from "@/components/Header.astro";
import type { MarkdownHeading } from "astro";
// Replaced lucide icon with inline SVG
// import ScreenGlow from "@/components/ScreenGlow.astro";

type Props = CollectionEntry<"blog">["data"] & { headings: MarkdownHeading[] };

const { title, description, pubDate, updatedDate, heroImage, headings } = Astro.props as Props;
const filteredHeadings = headings.filter((heading) => {
  const isDesiredDepth = heading.depth === 2 || heading.depth === 3;
  const isFootnotes =
    /footnotes?/i.test(heading.text) || heading.slug === "footnotes" || heading.slug === "footnote-label";
  return isDesiredDepth && !isFootnotes;
});

// Hierarchical TOC structure with h2 & nested h3 headings
const tocHeadings: (MarkdownHeading & { children: MarkdownHeading[] })[] = [];
let currentDepth2: (MarkdownHeading & { children: MarkdownHeading[] }) | null = null;

for (const heading of filteredHeadings) {
  if (heading.depth === 2) {
    currentDepth2 = { ...heading, children: [] };
    tocHeadings.push(currentDepth2);
  } else if (heading.depth === 3 && currentDepth2) {
    currentDepth2.children.push(heading);
  }
}
---

<html lang="en">
  <head>
    <BaseHead title={title} description={description} />
  </head>

  <body>
    <!-- <ScreenGlow /> -->
    <Header currentTitle={title} currentHref={Astro.url.pathname} />
    <main>
      <div class="gutter" aria-hidden="true"><!-- Fill Gutter --></div>
      <article>
        {heroImage && <img src={heroImage.src} alt="" class="hero-image" decoding="async" fetchpriority="high" />}
        <div class="prose">
          <header class="title">
            <h1>{title}</h1>
            <span class="date">
              <FormattedDate date={pubDate} />
              {
                updatedDate && (
                  <span class="last-updated-on">
                    Last updated on <FormattedDate date={updatedDate} />
                  </span>
                )
              }
            </span>
            <hr />
          </header>

          <slot />
        </div>
      </article>
      <aside class="toc-aside">
        <input type="checkbox" id="toc-toggle" class="toc-toggle" />
        <label
          for="toc-toggle"
          class="toc-fab"
          aria-controls="toc"
          aria-expanded="false"
          aria-haspopup="dialog"
          aria-label="Open table of contents"
          role="button"
          tabindex="0">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-table-of-contents-icon lucide-table-of-contents"
            aria-hidden="true"
            ><path d="M16 5H3"></path><path d="M16 12H3"></path><path d="M16 19H3"></path><path d="M21 5h.01"
            ></path><path d="M21 12h.01"></path><path d="M21 19h.01"></path></svg
          >
          <span class="sr-only">Contents</span>
        </label>
        <!-- Table of Contents -->
        <nav id="toc" aria-labelledby="toc-label">
          <h2 id="toc-label" class="sr-only">Table of contents</h2>
          <label for="toc-toggle" class="toc-close" aria-label="Close table of contents" role="button" tabindex="0"
            >Close</label
          >

          {
            tocHeadings.length > 0 ? (
              <ol>
                {tocHeadings.map((heading) => (
                  <li>
                    <a href={`#${heading.slug}`}>{heading.text}</a>
                    {heading.children.length > 0 && (
                      <ol>
                        {heading.children.map((child) => (
                          <li>
                            <a href={`#${child.slug}`}>{child.text}</a>
                          </li>
                        ))}
                      </ol>
                    )}
                  </li>
                ))}
              </ol>
            ) : (
              <span class="no-toc">This article does not have a table of contents.</span>
            )
          }
        </nav>
        <label for="toc-toggle" class="toc-scrim" aria-hidden="true"></label>
      </aside>
    </main>
    <Footer />
    <script>
      const tocEl = document.getElementById("toc") as HTMLElement | null;
      if (tocEl) {
        const FOCUS_OFFSET_TOP_PX = 72;
        const FOCUS_OFFSET_BOTTOM_PX = 256;

        let observedHeadings: HTMLElement[] = [];
        const idToLink = new Map<string, HTMLElement>();
        const h3ToParentH2Id = new Map<string, string>();
        const activeH2Ids = new Set<string>();
        const activeH3Ids = new Set<string>();
        let observer: IntersectionObserver | null = null;
        let fallbackH2Id: string | null = null;

        function mapIdToLink() {
          idToLink.clear();
          observedHeadings.forEach((h) => {
            const a = (tocEl as HTMLElement).querySelector<HTMLElement>(`a[href="#${h.id}"]`);
            if (a) idToLink.set(h.id, a);
          });
        }

        function buildHeadingRelations() {
          h3ToParentH2Id.clear();
          let lastH2Id: string | null = null;
          for (const el of observedHeadings) {
            if (el.tagName === "H2") lastH2Id = el.id;
            if (el.tagName === "H3" && lastH2Id) h3ToParentH2Id.set(el.id, lastH2Id);
          }
        }

        function applyObservedClasses() {
          (tocEl as HTMLElement).querySelectorAll("a.observed").forEach((a) => a.classList.remove("observed"));
          (tocEl as HTMLElement).querySelectorAll("li.observed").forEach((li) => li.classList.remove("observed"));
          (tocEl as HTMLElement)
            .querySelectorAll('a[aria-current="true"]')
            .forEach((a) => a.removeAttribute("aria-current"));

          activeH3Ids.forEach((id) => {
            const link = idToLink.get(id);
            if (!link) return;
            link.classList.add("observed");
            link.setAttribute("aria-current", "true");
            const li = link.closest("li");
            if (li) li.classList.add("observed");
          });

          const toHighlightH2 = new Set<string>(activeH2Ids);
          if (fallbackH2Id) toHighlightH2.add(fallbackH2Id);
          activeH3Ids.forEach((h3id) => {
            const parentId = h3ToParentH2Id.get(h3id);
            if (parentId) toHighlightH2.add(parentId);
          });
          toHighlightH2.forEach((id) => {
            const link = idToLink.get(id);
            if (!link) return;
            link.classList.add("observed");
            link.setAttribute("aria-current", "true");
            const li = link.closest("li");
            if (li) li.classList.add("observed");
          });
        }

        function computeFallbackH2Id() {
          fallbackH2Id = null;
          if (activeH2Ids.size > 0) return;
          const viewportHeight = window.visualViewport?.height ?? window.innerHeight;
          const topPx = FOCUS_OFFSET_TOP_PX;
          const bottomPx = FOCUS_OFFSET_BOTTOM_PX;
          const focusTop = topPx;
          const focusBottom = viewportHeight - bottomPx;
          const h2s = observedHeadings.filter((h) => h.tagName === "H2");

          for (let i = 0; i < h2s.length; i++) {
            const cur = h2s[i];
            if (!cur) continue;
            const next = i + 1 < h2s.length ? h2s[i + 1] : null;
            const curTop = cur.getBoundingClientRect().top;
            const nextTop = next ? next.getBoundingClientRect().top : Number.POSITIVE_INFINITY;
            if (curTop <= focusTop && nextTop > focusTop) {
              fallbackH2Id = cur.id;
              return;
            }
          }
          for (const cur of h2s) {
            const rect = cur.getBoundingClientRect();
            if (rect.bottom > focusTop && rect.top < focusBottom) {
              fallbackH2Id = cur.id;
              return;
            }
          }
        }

        function connectObserver() {
          const topPx = FOCUS_OFFSET_TOP_PX;
          const bottomPx = FOCUS_OFFSET_BOTTOM_PX;
          observer = new IntersectionObserver(
            (entries) => {
              for (const entry of entries) {
                const el = entry.target as HTMLElement;
                const id = el.id;
                const isH2 = el.tagName === "H2";
                const isH3 = el.tagName === "H3";

                if (isH2) {
                  if (entry.isIntersecting) activeH2Ids.add(id);
                  else activeH2Ids.delete(id);
                } else if (isH3) {
                  if (entry.isIntersecting) activeH3Ids.add(id);
                  else activeH3Ids.delete(id);
                }
              }
              computeFallbackH2Id();
              applyObservedClasses();
            },
            {
              root: null,
              rootMargin: `-${topPx}px 0px -${bottomPx}px 0px`,
              threshold: [0],
            }
          );

          observedHeadings.forEach((h) => observer?.observe(h));
        }

        function disconnectObserver() {
          if (observer) {
            observer.disconnect();
            observer = null;
          }
        }

        function primeInitialHighlight() {
          activeH2Ids.clear();
          activeH3Ids.clear();
          const viewportHeight = window.visualViewport?.height ?? window.innerHeight;
          const topPx = FOCUS_OFFSET_TOP_PX;
          const bottomPx = FOCUS_OFFSET_BOTTOM_PX;
          const topBound = topPx;
          const bottomBound = viewportHeight - bottomPx;
          for (const el of observedHeadings) {
            const rect = el.getBoundingClientRect();
            const intersects = rect.bottom > topBound && rect.top < bottomBound;
            if (!intersects) continue;
            if (el.tagName === "H2") activeH2Ids.add(el.id);
            if (el.tagName === "H3") activeH3Ids.add(el.id);
          }
          computeFallbackH2Id();
          applyObservedClasses();
        }

        function initTOC() {
          const headings = Array.from(document.querySelectorAll(".prose h2[id], .prose h3[id]")) as HTMLElement[];
          const isNotFootnotes = (el: HTMLElement) => el.id !== "footnote-label" && !el.closest(".footnotes");
          observedHeadings = headings.filter((h) => !!h.id && isNotFootnotes(h));

          mapIdToLink();
          buildHeadingRelations();

          (tocEl as HTMLElement).querySelectorAll("a.observed").forEach((a) => a.classList.remove("observed"));
          (tocEl as HTMLElement).querySelectorAll("li.observed").forEach((li) => li.classList.remove("observed"));
          (tocEl as HTMLElement)
            .querySelectorAll('a[aria-current="true"]')
            .forEach((a) => a.removeAttribute("aria-current"));

          disconnectObserver();
          connectObserver();
          primeInitialHighlight();
        }

        initTOC();

        let rafScheduled = false;
        function scheduleRecompute() {
          if (rafScheduled) return;
          rafScheduled = true;
          requestAnimationFrame(() => {
            rafScheduled = false;
            computeFallbackH2Id();
            applyObservedClasses();
          });
        }
        window.addEventListener("scroll", scheduleRecompute, { passive: true } as AddEventListenerOptions);
        window.addEventListener("resize", scheduleRecompute, { passive: true } as AddEventListenerOptions);
        document.addEventListener("astro:after-swap", initTOC as EventListener);

        // Mobile drawer a11y: keep aria-expanded in sync, trap focus, restore focus, close on link click
        const tocToggle = document.getElementById("toc-toggle") as HTMLInputElement | null;
        const toggleButtons = Array.from(document.querySelectorAll(".toc-fab, .toc-nav-toggle")) as HTMLElement[];
        let lastFocusedBeforeOpen: HTMLElement | null = null;

        function getFocusable(container: ParentNode): HTMLElement[] {
          const selector = [
            'a[href]:not([tabindex="-1"])',
            'button:not([disabled]):not([tabindex="-1"])',
            'input:not([disabled]):not([type="hidden"]):not([tabindex="-1"])',
            'select:not([disabled]):not([tabindex="-1"])',
            'textarea:not([disabled]):not([tabindex="-1"])',
            '[tabindex]:not([tabindex="-1"])',
          ].join(",");
          return Array.from(container.querySelectorAll<HTMLElement>(selector));
        }

        const updateTocAria = () => {
          const isOpen = !!tocToggle?.checked;
          toggleButtons.forEach((btn) => btn.setAttribute("aria-expanded", String(isOpen)));
          document.body.style.overflow = isOpen ? "hidden" : "";
          // Global CSS sets symmetric gutter. No dynamic toggle needed here.

          if (isOpen) {
            lastFocusedBeforeOpen = (document.activeElement as HTMLElement) ?? null;
            const focusables = getFocusable(tocEl);
            const first = focusables[0];
            if (first) first.focus();
          } else {
            if (lastFocusedBeforeOpen) lastFocusedBeforeOpen.focus();
          }
        };

        tocToggle?.addEventListener("change", updateTocAria);

        document.addEventListener("keydown", (e) => {
          if (!tocToggle?.checked) return;
          if (e.key !== "Tab") return;
          const focusables = getFocusable(tocEl);
          if (focusables.length === 0) return;
          const first = focusables[0] as HTMLElement | undefined;
          const last = focusables[focusables.length - 1] as HTMLElement | undefined;
          const active = document.activeElement as HTMLElement | null;
          if (e.shiftKey) {
            if ((first && active === first) || !tocEl.contains(active)) {
              e.preventDefault();
              (last ?? tocEl).focus();
            }
          } else {
            if ((last && active === last) || !tocEl.contains(active)) {
              e.preventDefault();
              (first ?? tocEl).focus();
            }
          }
        });

        tocEl.addEventListener("click", (ev) => {
          const target = ev.target as HTMLElement | null;
          if (!target) return;
          if (target.matches('a[href^="#"]')) {
            if (tocToggle) tocToggle.checked = false;
            updateTocAria();
          }
        });

        document.addEventListener("astro:after-swap", updateTocAria as EventListener);

        // Swipe-down-to-close on mobile
        let touchStartY = 0;
        let touchStartX = 0;
        const SWIPE_THRESHOLD_PX = 50;
        const HORIZONTAL_TOLERANCE_PX = 60;
        tocEl.addEventListener(
          "touchstart",
          (e: TouchEvent) => {
            if (!e.changedTouches || e.changedTouches.length === 0) return;
            const t = e.changedTouches.item(0);
            if (!t) return;
            touchStartY = t.clientY;
            touchStartX = t.clientX;
          },
          { passive: true } as AddEventListenerOptions
        );
        tocEl.addEventListener(
          "touchend",
          (e: TouchEvent) => {
            if (!tocToggle?.checked) return;
            if (!e.changedTouches || e.changedTouches.length === 0) return;
            const t = e.changedTouches.item(0);
            if (!t) return;
            const deltaY = t.clientY - touchStartY;
            const deltaX = Math.abs(t.clientX - touchStartX);
            if (deltaY > SWIPE_THRESHOLD_PX && deltaX < HORIZONTAL_TOLERANCE_PX) {
              tocToggle.checked = false;
              updateTocAria();
            }
          },
          { passive: true } as AddEventListenerOptions
        );
      }
    </script>
  </body>
</html>
